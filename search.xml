<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>descriptor</title>
    <url>/2020/03/12/descriptor/</url>
    <content><![CDATA[<h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><h3 id="描述符的定义"><a href="#描述符的定义" class="headerlink" title="描述符的定义"></a>描述符的定义</h3><blockquote>
<p> 描述符的作用是用来代理另外一个类的属性的 (必须把描述符定义成这个类的类属性，不能定义到构造函数中)</p>
</blockquote>
<h3 id="前面的铺垫-各个优先级"><a href="#前面的铺垫-各个优先级" class="headerlink" title="前面的铺垫-各个优先级"></a>前面的铺垫-各个优先级</h3><blockquote>
<p><a href="https://www.cnblogs.com/linhaifeng/articles/6204014.html#sr-toc-10" target="_blank" rel="noopener">https://www.cnblogs.com/linhaifeng/articles/6204014.html#sr-toc-10</a><br>关于数据描述符和非数据描述以及他们和类属性实例属性之间的优先级请看上面的博文链接，这里不会赘述太多。这里只会分享一下我的心得和发现。</p>
</blockquote>
<p>你只要知道这些：<br>在一般情况下，</p>
<p>一 描述符本身应该定义成新式类, 被代理的类也应该是新式类</p>
<p>二 必须把描述符定义成这个类的类属性，不能为定义到构造函数中</p>
<p>三 要严格遵循该优先级, 优先级由高到底分别是</p>
<ol>
<li>类属性</li>
<li>数据描述符</li>
<li>实例属性</li>
<li>非数据描述符</li>
<li>找不到的属性触发<strong>getattr</strong>()</li>
</ol>
<p>但这并不是完全正确，我在下面会将，请耐心看完</p>
<h3 id="描述符的使用"><a href="#描述符的使用" class="headerlink" title="描述符的使用"></a>描述符的使用</h3><h4 id="描述符配合类的装饰器控制实例属性类型"><a href="#描述符配合类的装饰器控制实例属性类型" class="headerlink" title="描述符配合类的装饰器控制实例属性类型"></a>描述符配合类的装饰器控制实例属性类型</h4><ul>
<li>代码<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typed</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,expected_type)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.expected_type=expected_type</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'get---&gt;'</span>,instance,owner)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'set---&gt;'</span>,instance,value)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value,self.expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected %s'</span> %str(self.expected_type))</span><br><span class="line">        instance.__dict__[self.name]=value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'delete---&gt;'</span>,instance)</span><br><span class="line">        instance.__dict__.pop(self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeassert</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'类的装饰器开始运行啦------&gt;'</span>,kwargs)</span><br><span class="line">        <span class="keyword">for</span> name,expected_type <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            setattr(cls,name,Typed(name,expected_type))</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"><span class="meta">@typeassert(name=str,age=int,salary=float) #有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,salary)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.salary=salary</span><br><span class="line"></span><br><span class="line"><span class="comment">#有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs</span></span><br><span class="line"><span class="comment"># 2.People=decorate(People)</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'People-----'</span>,People.__dict__)  <span class="comment"># 在decorate(People)装饰符的函数中加了数据装饰符属性</span></span><br><span class="line">p1=People(<span class="string">'egon'</span>,<span class="number">18</span>,<span class="number">3333.3</span>)</span><br><span class="line">print(<span class="string">'People.name'</span>,People.name)</span><br><span class="line">print(<span class="string">'p1-----'</span>,p1.__dict__) <span class="comment"># 因为 instance.__dict__[self.name]=value的缘故，p1中也添加了这些实例属性</span></span><br><span class="line">print(<span class="string">'People-----'</span>,People.__dict__)</span><br><span class="line">print(p1.name) <span class="comment"># 因为数据装饰符的优先级大于实例属性，</span></span><br><span class="line">                <span class="comment"># 所有这里的name其实是描述符，然后调用了描述符中的get方法，</span></span><br><span class="line">                <span class="comment"># 返回了实例中的实例属性name</span></span><br><span class="line">p1.name = <span class="string">'das'</span></span><br><span class="line">print(p1.name)</span><br></pre></td></tr></table></figure></li>
<li>运行结果为：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类的装饰器开始运行啦------&gt; &#123;'name': &lt;class 'str'&gt;, 'age': &lt;class 'int'&gt;, 'salary': &lt;class 'float'&gt;&#125;</span><br><span class="line">People----- &#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__init__'</span>: &lt;function People.__init__ at <span class="number">0x0000024CE7A98730</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'name'</span>: &lt;__main__.Typed object at <span class="number">0x0000024CE7A73588</span>&gt;, <span class="string">'age'</span>: &lt;__main__.Typed object at <span class="number">0x0000024CE7A735F8</span>&gt;, <span class="string">'salary'</span>: &lt;__main__.Typed object at <span class="number">0x0000024CE7A735C0</span>&gt;&#125;</span><br><span class="line">set---&gt; &lt;__main__.People object at 0x0000024CE7A73A58&gt; egon</span><br><span class="line">set---&gt; &lt;__main__.People object at 0x0000024CE7A73A58&gt; 18</span><br><span class="line">set---&gt; &lt;__main__.People object at 0x0000024CE7A73A58&gt; 3333.3</span><br><span class="line">get---&gt; None &lt;class '__main__.People'&gt;</span><br><span class="line">People.name &lt;__main__.Typed object at <span class="number">0x0000024CE7A73588</span>&gt;</span><br><span class="line">p1----- &#123;<span class="string">'name'</span>: <span class="string">'egon'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'salary'</span>: <span class="number">3333.3</span>&#125;</span><br><span class="line">People----- &#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__init__'</span>: &lt;function People.__init__ at <span class="number">0x0000024CE7A98730</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'name'</span>: &lt;__main__.Typed object at <span class="number">0x0000024CE7A73588</span>&gt;, <span class="string">'age'</span>: &lt;__main__.Typed object at <span class="number">0x0000024CE7A735F8</span>&gt;, <span class="string">'salary'</span>: &lt;__main__.Typed object at <span class="number">0x0000024CE7A735C0</span>&gt;&#125;</span><br><span class="line">get---&gt; &lt;__main__.People object at 0x0000024CE7A73A58&gt; &lt;class '__main__.People'&gt;</span><br><span class="line">egon</span><br><span class="line">set---&gt; &lt;__main__.People object at 0x0000024CE7A73A58&gt; das</span><br><span class="line">get---&gt; &lt;__main__.People object at 0x0000024CE7A73A58&gt; &lt;class '__main__.People'&gt;</span><br><span class="line">das</span><br></pre></td></tr></table></figure>
<ul>
<li>分析运行过程</li>
</ul>
<p>1.首先这里是有参数的类修饰符，==typeassert==函数返回的是==decorate==函数，当编译到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@typeassert(name=str,age=int,salary=float) #有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br></pre></td></tr></table></figure>
<p>时，执行的为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs</span></span><br><span class="line"><span class="comment"># 2.People=decorate(People)</span></span><br></pre></td></tr></table></figure>
<p>2.在==decorate==函数中，将**kwargs中key转换为==People类==中的同名的数据描述符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setattr(cls,name,Typed(name,expected_type))</span><br></pre></td></tr></table></figure>
<p>所以我们可以看到==People==打印出来的结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">People----- &#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__init__'</span>: &lt;function People.__init__ at <span class="number">0x0000024CE7A98730</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'name'</span>: &lt;__main__.Typed object at <span class="number">0x0000024CE7A73588</span>&gt;, <span class="string">'age'</span>: &lt;__main__.Typed object at <span class="number">0x0000024CE7A735F8</span>&gt;, <span class="string">'salary'</span>: &lt;__main__.Typed object at <span class="number">0x0000024CE7A735C0</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>他是包含==name,age,salary==的，并且可以出现在类的<strong>dict</strong>中<br>3.实例化==People==类，创建==p1==实例，执行了==init==方法，但由于数据描述符的优先级大于实例属性，所以==self.name==，这个==name==其实是数据描述符。age和salary也是同理，所以会打印出如下信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">set---&gt; &lt;__main__.People object at 0x0000024CE7A73A58&gt; egon</span><br><span class="line">set---&gt; &lt;__main__.People object at 0x0000024CE7A73A58&gt; 18</span><br><span class="line">set---&gt; &lt;__main__.People object at 0x0000024CE7A73A58&gt; 3333.3</span><br></pre></td></tr></table></figure>
<p>全都触发了，描述符类中的==set==方法，再看set方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">    print(<span class="string">'set---&gt;'</span>,instance,value)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value,self.expected_type):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'Expected %s'</span> %str(self.expected_type))</span><br><span class="line">    instance.__dict__[self.name]=value</span><br></pre></td></tr></table></figure>
<p>这里的==instance==指的就是传过来的==p1==实例对象，set中做的事就是让符合条件的数据编程p1的实例属性（我们都知道实例的<strong>dict</strong>中代表的是实例属性）</p>
<p>可能有人会问，传过来的参数那么多，==set==怎么就知道每个值对应的==self.name==呢？</p>
<blockquote>
<p>这位同学犯了一个理解性错误，在decorate函数中，他是为每一个**kwargs中的都key创建了一个描述符，所有name.age.salary都只会对应一个描述符类的实例。self.name是他们自身的实例属性，有且只有<br>一个，当我们在init使用self.name = name时，它实际上只的就是name这个描述符实例。</p>
</blockquote>
<p>经过set方法，p1中也会包含==name,age,salary==这样名称的实例属性，可以==看出p1.<strong>dict</strong>的==打印结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p1----- &#123;<span class="string">'name'</span>: <span class="string">'egon'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'salary'</span>: <span class="number">3333.3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>而与此同时People类中还是会包含==name,age,salary==描述符类属性，可以看==People.<strong>dict</strong>的==打印结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">People----- &#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__init__'</span>: &lt;function People.__init__ at <span class="number">0x000001DBCD9E8730</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'name'</span>: &lt;__main__.Typed object at <span class="number">0x000001DBCD9C3588</span>&gt;, <span class="string">'age'</span>: &lt;__main__.Typed object at <span class="number">0x000001DBCD9C35F8</span>&gt;, <span class="string">'salary'</span>: &lt;__main__.Typed object at <span class="number">0x000001DBCD9C35C0</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>之后当我们执行==p1.name==获取==name==时，因为数据描述符的优先级大于实例属性，所有获取的仍然是name数据描述符类，他仍然会执行==get==方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">get---&gt; &lt;__main__.People object at 0x000001DBCD9C3A58&gt; &lt;class '__main__.People'&gt;</span><br></pre></td></tr></table></figure>
<p>而由于get方法的返回值是==instance.<strong>dict</strong>[self.name]==，所有他返回的还是p1的实例属性name,于是就打印出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">egon</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里顺便插一句，get方法中的instance指的就是调用它的实例，owner指的就是这个描述符所在的类，所有当我们使用People.name直接调用时，instance的值就是None:</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">get---&gt; None &lt;class '__main__.People'&gt;</span><br></pre></td></tr></table></figure>
<p>而我们直接返回描述符实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">People.name &lt;__main__.Typed object at <span class="number">0x000001DBCD9C3588</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>叨叨几句，如果这里使用People.name = ‘clearlove’会触发描述符中的set方法吗？答案是不会，因为类属性的优先级大于实例属性，他会在类的<strong>dict</strong>创建同名的name覆盖掉原来的name,同样，删除也不会触发<strong>delete</strong>，在使用类删除他只会把数据描述符当做类属性删除，<strong>所以最后不要用类去操作描述符</strong>。</p>
</blockquote>
<p>我们接着往下看，当我们执行到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p1.name = <span class="string">'das'</span></span><br></pre></td></tr></table></figure>
<p>因为数据描述符的优先级大于实例属性，所以还是会触发==set==方法，打印：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">set---&gt; &lt;__main__.People object at 0x000001AF6F043AC8&gt; das</span><br></pre></td></tr></table></figure>
<p>然后我们将==p1.name==打印出来又会触发==get==方法，打印出来</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">get---&gt; &lt;__main__.People object at 0x000001AF6F043AC8&gt; &lt;class '__main__.People'&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用描述符自定制-porperty"><a href="#使用描述符自定制-porperty" class="headerlink" title="使用描述符自定制@porperty"></a>使用描述符自定制@porperty</h3><p>到了这一步，我们算是对了描述符有了些基本的认识，但千万别以为自己已经掌握了描述符的应用，不信？我们看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myproperty</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        print(<span class="string">'init....'</span>)</span><br><span class="line">        self.name = func.__name__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'执行了get'</span>, instance, owner)</span><br><span class="line">        <span class="comment"># print('in dict',instance.__dict__)</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">if</span> self.name <span class="keyword">not</span> <span class="keyword">in</span> instance.__dict__:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(instance, <span class="string">'object no attribute'</span>, self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'执行了set'</span>, instance, value)</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'执行了delete'</span>)</span><br><span class="line">        instance.__dict__.pop(self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        print(<span class="string">'执行了setter'</span>, func)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># job = 6</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, salary)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  # city = property(city)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">city</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__city  <span class="comment"># 报错，因为会无限递归，所以porperty中最好使用私有变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @city.setter  # city = property(city).setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">city</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__city = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @myproperty  # job = myproperty(job)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__job</span><br><span class="line"></span><br><span class="line">    print(job) <span class="comment">#myproperty对象 &lt;__main__.myproperty object at 0x0000025C69B33550&gt;</span></span><br><span class="line"><span class="meta">    @job.setter  # job = job&lt;myproperty object&gt;.setter(job)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">'set __ job'</span>)</span><br><span class="line">        self.__job = value</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'-----2'</span>,job) <span class="comment"># &lt;__main__.myproperty object at 0x00000244592C3B38&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xxx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xxx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.__class__)</span><br><span class="line"></span><br><span class="line">p1 = People(<span class="string">'张三'</span>, <span class="number">18</span>, <span class="number">2000.00</span>)</span><br><span class="line"><span class="comment"># p1.city = '上海'</span></span><br><span class="line"><span class="comment"># print(p1.city)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(p1.xxx)</span></span><br><span class="line">print(People.__dict__)</span><br><span class="line">print(p1.__dict__)</span><br><span class="line"><span class="comment"># print(p1.job)  # 如果myproperty是只实现了get方法的非数据描述符，那么p1.job会找到下面重载的job函数（他会覆盖上面的job函数），他相当于类属性，但是实例也可以调用</span></span><br><span class="line"><span class="comment"># 如果把重载job函数注释掉，那么他就会找到这个非数据描述符，并执行其中的get方法,而且因为get中没有设置返回值，所有打印出来是None</span></span><br><span class="line"><span class="comment"># 如果把重载job函数注释掉,在描述符类中添加set那么就会找到这个优先级较高的描述符，并执行相应的方法</span></span><br><span class="line"><span class="comment"># 如果重载job函数,那么即使在描述符类中添加set，也只会找到job函数，因为类属性的优先级大于描述符,但是调用类的方法（）却是相当于调用非数据描述符</span></span><br><span class="line"><span class="comment"># 问题？如果说函数是非数据描述符的话，为什么这里的优先级会比数据描述符大呢</span></span><br><span class="line"><span class="comment"># 不管了，反正只要不同名就行了</span></span><br><span class="line"><span class="comment"># print(p1.xxx())</span></span><br><span class="line"><span class="comment"># print(p1.xxx(2))</span></span><br><span class="line">p1.job = <span class="string">'dsa'</span></span><br><span class="line">print(<span class="string">'p1-------'</span>,p1.job)</span><br><span class="line">print(<span class="string">'People------'</span>,People.job)</span><br><span class="line">print(p1.__dict__)</span><br><span class="line">print(People.__dict__)</span><br></pre></td></tr></table></figure>
<p>他的运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init....</span><br><span class="line">&lt;__main__.myproperty object at <span class="number">0x000001FDE76B36A0</span>&gt;</span><br><span class="line">执行了setter &lt;function People.job at <span class="number">0x000001FDE76D8840</span>&gt;</span><br><span class="line">----<span class="number">-2</span> &lt;__main__.myproperty object at <span class="number">0x000001FDE76B36A0</span>&gt;</span><br><span class="line">&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__init__'</span>: &lt;function People.__init__ at <span class="number">0x000001FDE76D86A8</span>&gt;, <span class="string">'city'</span>: &lt;property object at <span class="number">0x000001FDE76ACE08</span>&gt;, <span class="string">'job'</span>: &lt;__main__.myproperty object at <span class="number">0x000001FDE76B36A0</span>&gt;, <span class="string">'xxx'</span>: &lt;function People.xxx at <span class="number">0x000001FDE76D88C8</span>&gt;, <span class="string">'__repr__'</span>: &lt;function People.__repr__ at <span class="number">0x000001FDE76D8840</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'张三'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'salary'</span>: <span class="number">2000.0</span>&#125;</span><br><span class="line">执行了set &lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">People</span>'&gt; <span class="title">dsa</span></span></span><br><span class="line"><span class="class">执行了<span class="title">get</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">People</span>'&gt; &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">People</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">p1</span>------- <span class="title">dsa</span></span></span><br><span class="line"><span class="class">执行了<span class="title">get</span> <span class="title">None</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">People</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">People</span>------ &lt;<span class="title">__main__</span>.<span class="title">myproperty</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x000001FDE76B36A0</span>&gt;</span></span><br><span class="line">&#123;'name': '张三', 'age': 18, 'salary': 2000.0, 'job': 'dsa'&#125;</span><br><span class="line">&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__init__'</span>: &lt;function People.__init__ at <span class="number">0x000001FDE76D86A8</span>&gt;, <span class="string">'city'</span>: &lt;property object at <span class="number">0x000001FDE76ACE08</span>&gt;, <span class="string">'job'</span>: &lt;__main__.myproperty object at <span class="number">0x000001FDE76B36A0</span>&gt;, <span class="string">'xxx'</span>: &lt;function People.xxx at <span class="number">0x000001FDE76D88C8</span>&gt;, <span class="string">'__repr__'</span>: &lt;function People.__repr__ at <span class="number">0x000001FDE76D8840</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>


<p>这是我自己摸索着创建的描述符，并不是很完善，但依然可以发现许多有趣的现象，让我们来分析一下运行流程：</p>
<p>1.首先当编译到这里时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@myproperty  # job = myproperty(job)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__job</span><br></pre></td></tr></table></figure>
<p>实际上运行的是 ==job = myproperty(job)==，所以才会打印出init的信息，<br>我们把job打印出来可以看到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;__main__.myproperty object at <span class="number">0x000001F2F61B3550</span>&gt;</span><br><span class="line"><span class="comment"># 他其实就是一个myproperty描述符类对象</span></span><br></pre></td></tr></table></figure>
<p>而当我们编译到这里时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@job.setter  # job = job&lt;myproperty object&gt;.setter(job)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    print(<span class="string">'set __ job'</span>)</span><br><span class="line">    self.__job = value</span><br></pre></td></tr></table></figure>
<p>他实际上执行的是：==job = job<myproperty object>.setter(job)==<br>，是执行上面创建的==myproperty==对象的==setter==方法：所以这里我们需要在setter方法中返回自身的实例，好让job继续保持描述符对象的身份：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">(self, func)</span>:</span></span><br><span class="line">      print(<span class="string">'执行了setter'</span>, func)</span><br><span class="line">      <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>
<blockquote>
<p>明确一点，当使用@area修饰一个class或者def时，他的运行流程其实是 class_name = area(class_name)</p>
</blockquote>
<p>3.我们创建p1实例之后，到这一步我们把==People.dict==和==p1.__dict==都打印出来看看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__init__'</span>: &lt;function People.__init__ at <span class="number">0x000001FDE76D86A8</span>&gt;, <span class="string">'city'</span>: &lt;property object at <span class="number">0x000001FDE76ACE08</span>&gt;, <span class="string">'job'</span>: &lt;__main__.myproperty object at <span class="number">0x000001FDE76B36A0</span>&gt;, <span class="string">'xxx'</span>: &lt;function People.xxx at <span class="number">0x000001FDE76D88C8</span>&gt;, <span class="string">'__repr__'</span>: &lt;function People.__repr__ at <span class="number">0x000001FDE76D8840</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'张三'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'salary'</span>: <span class="number">2000.0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到job是作为数据描述符放入到类的dict中的，并且只有一份，而p1的实例属性只有在init中创建的三个。</p>
<p>后面的==p1.job = ‘dsa’== 就会触发set方法，打印出来就会出发get方法，而至于==People.job==，他会先去类属性当中找有没有job，没有就去数据描述符中找，找到了，就会触发get方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">执行了set &lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">People</span>'&gt; <span class="title">dsa</span></span></span><br><span class="line"><span class="class">执行了<span class="title">get</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">People</span>'&gt; &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">People</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">p1</span>------- <span class="title">dsa</span></span></span><br><span class="line"><span class="class">执行了<span class="title">get</span> <span class="title">None</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">People</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">People</span>------ &lt;<span class="title">__main__</span>.<span class="title">myproperty</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x000001FDE76B36A0</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有一点值得注意，对象调用时打印出来的是People类，但是测试发现确实是p1实例，这是个未解之谜，搞不懂也没事，可以忽略这段话</p>
</blockquote>
<p>最后再次把实例和类的==dict==打印出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'张三'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'salary'</span>: <span class="number">2000.0</span>, <span class="string">'job'</span>: <span class="string">'dsa'</span>&#125;</span><br><span class="line">&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__init__'</span>: &lt;function People.__init__ at <span class="number">0x000001FDE76D86A8</span>&gt;, <span class="string">'city'</span>: &lt;property object at <span class="number">0x000001FDE76ACE08</span>&gt;, <span class="string">'job'</span>: &lt;__main__.myproperty object at <span class="number">0x000001FDE76B36A0</span>&gt;, <span class="string">'xxx'</span>: &lt;function People.xxx at <span class="number">0x000001FDE76D88C8</span>&gt;, <span class="string">'__repr__'</span>: &lt;function People.__repr__ at <span class="number">0x000001FDE76D8840</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'People'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到job出现在了实例属性中，这是因为get方法中做了处理，处理方式和上一个例子相同，这里就不再多赘述了。</p>
<p>但是我们发现，这样子子写，不会执行job函数中的方法，所有这不是正规的property,我在网上找了分正规的，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget)</span>:</span></span><br><span class="line">        self.fget = fget    <span class="comment"># 为实例增加方法，这里的方法是未绑定实例的，不会自动传入实例self</span></span><br><span class="line">        self.fset = <span class="literal">None</span>    <span class="comment"># 同上，未绑定实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fget(instance)  <span class="comment"># 调用原方法，传入实例self</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        self.fset(instance, value)  <span class="comment"># 调用原方法，传入实例self和value</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.fset = func  <span class="comment"># 更新属性</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self._data = data</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Property  # data = Property(data) 描述符实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._data</span><br><span class="line"></span><br><span class="line"><span class="meta">    @data.setter  # data = data.setter(data) 更新属性，并返回描述符实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._data = value</span><br></pre></td></tr></table></figure>

<p>可以看到，他的思路和我们原来的大体相同，<strong>最核心的内容还是要把data转换成另一个类的实例（描述符）</strong>，主要的区别是，他在这个类的实例中分别保存了自定义的==get== 和 ==set==方法，这样我们在调用描述符时，他其实就是调用的==get/set==方法，而后又在==get/set==方法中调用了之前保存的自定义方法，<strong>所以达到了和@property 相同的效果</strong></p>
<p>到这里，我们必须明确的三个概念是：</p>
<p>1.使用装饰器的本质就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Property  # data = Property(data) 描述符实例</span></span><br><span class="line"><span class="meta">@data.setter  # data = data.setter(data)</span></span><br></pre></td></tr></table></figure>
<p>2.描述符的触发时机</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = A()</span><br><span class="line">a.data   <span class="comment"># 触发get</span></span><br><span class="line">a.data = <span class="string">'111'</span>  <span class="comment"># 触发set</span></span><br><span class="line"><span class="keyword">del</span> a  <span class="comment"># 触发delete</span></span><br><span class="line"></span><br><span class="line">A.data  <span class="comment"># 触发get</span></span><br><span class="line">A.data = <span class="string">'222'</span> <span class="comment"># 不仅不会触发，还会同名的类属性data覆盖掉描述符</span></span><br><span class="line"><span class="keyword">del</span> A.data  <span class="comment"># 不会触发，类只会将data当做类属性删掉</span></span><br></pre></td></tr></table></figure>
<p>3.@property的本质</p>
<blockquote>
<p>我们知道python中是不会重载函数的,后面编译的同名函数（包括类属性）会覆盖掉上面的，之所以@property看起来像是突破了这一限制，同时保留了data同名方法，但时机上却是将data转换成了一个描述符，这一点我们可以从打印类的==dict==中看到，他只会保留一个data，他就是描述符类的实例。而在这个实例中，保存了我们自定义==的get/set==方法，并分别放在了描述符类的==get/set==方法中，这样，就可以达到以假乱真的地步</p>
</blockquote>
<h3 id="实例属性的优先级补充"><a href="#实例属性的优先级补充" class="headerlink" title="实例属性的优先级补充"></a>实例属性的优先级补充</h3><p>如果你看到了，这里，你已经是一个很有毅力的人了，但是，千万不要以为自己已经掌握python优先级的魔法，我们还没有得出最后的结论，因为我发现了这个例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    address = <span class="string">'zhejiang'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">'Person.address = '</span> + Person.address  <span class="comment"># zhejiang</span></span><br><span class="line"> </span><br><span class="line">p1.address = <span class="string">'shanxi'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'p1.address = '</span> + p1.address  <span class="comment"># shanxi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">'Person.address = '</span> + Person.address   <span class="comment"># zhejiang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'p2.address = '</span> + p2.address  <span class="comment"># zhejiang</span></span><br></pre></td></tr></table></figure>
<p>可见，千万不要在实例上修改类属性，它实际上并没有修改类属性，而是给实例绑定了一个实例属性。因为：</p>
<p><strong>当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。</strong></p>
<p>那么问题来了，不是说好的，类属性&gt;数据描述符&gt;实例属性&gt;非数据描述符&gt;找不到属性的getattr方法吗？？？</p>
<p>少年，我也很无奈啊，所以经过测试，得出以下结论：</p>
<hr>
<p>在一般情况下，</p>
<p>一 描述符本身应该定义成新式类, 被代理的类也应该是新式类</p>
<p>二 必须把描述符定义成这个类的类属性，不能为定义到构造函数中</p>
<p>三 要严格遵循该优先级, 优先级由高到底分别是</p>
<ol>
<li>类属性</li>
<li>数据描述符</li>
<li>实例属性</li>
<li>非数据描述符</li>
<li>找不到的属性触发<strong>getattr</strong>()</li>
</ol>
<p>但是，当我们使用实例来调用时，如果这时候同时存在==与实例属性同名的类属性或函数==，实例属性的优先级大于一切！！！</p>
<hr>
<p>如果你都沒有看懂以上的所有内容，那么也没有关系，你只需要在实际应用中牢记以下4点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>不要用类去调用描述符！！！</span><br><span class="line"><span class="number">2.</span>不要用实例去调用类属性！！！</span><br><span class="line"><span class="number">3.</span>类属性请不要用和（实例属性<span class="keyword">and</span>描述符）相同的名字！！！ <span class="comment"># 注意这里的逻辑顺序</span></span><br><span class="line"><span class="number">4.</span>清楚的认识到描述符的本质就是用一个类的实例去充分充当另一个类中的属性（存放在类dict中），并且明白对象调用它时，get/set/delete的执行时机就可以了！！！</span><br></pre></td></tr></table></figure>
<h3 id="补充描述符应用，自定制-classmethod-staticmethod"><a href="#补充描述符应用，自定制-classmethod-staticmethod" class="headerlink" title="补充描述符应用，自定制@classmethod,@staticmethod"></a>补充描述符应用，自定制@classmethod,@staticmethod</h3><p>最后，补充描述符实现@classmethod，和@staticmethod的应用，可以先自己试一下，再看源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclassmethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            result = self.func(owner,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mystaticmethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            result = self.func(*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></span><br><span class="line">    job = <span class="string">'cooker'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,salary)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">achievejob</span><span class="params">(cls,name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> name+cls.job</span><br><span class="line"></span><br><span class="line"><span class="meta">    @myclassmethod  # obtainjob = myclassmethod(obtainjob)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">obtainjob</span><span class="params">(cls,name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> name+cls.job</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gainAdress</span><span class="params">(city)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'live in'</span>+city</span><br><span class="line"></span><br><span class="line"><span class="meta">    @mystaticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAdress</span><span class="params">(city)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'live in'</span>+city</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = People(<span class="string">'李白'</span>,<span class="number">20</span>,<span class="number">66666.66</span>)</span><br><span class="line">print(p1.achievejob(<span class="string">'tom'</span>)) <span class="comment"># tomcooker</span></span><br><span class="line">print(People.achievejob(<span class="string">'tom'</span>)) <span class="comment"># tomcooker</span></span><br><span class="line"></span><br><span class="line">print(p1.obtainjob(<span class="string">'faker'</span>)) <span class="comment"># fakercooker</span></span><br><span class="line">print(People.obtainjob(<span class="string">'faker'</span>)) <span class="comment"># fakercooker</span></span><br><span class="line"></span><br><span class="line">print(p1.gainAdress(<span class="string">'成都'</span>)) <span class="comment"># live in成都</span></span><br><span class="line">print(People.gainAdress(<span class="string">'成都'</span>)) <span class="comment"># live in成都</span></span><br><span class="line"></span><br><span class="line">print(p1.getAdress(<span class="string">'常州'</span>)) <span class="comment"># live in常州</span></span><br><span class="line">print(People.getAdress(<span class="string">'常州'</span>)) <span class="comment"># live in常州</span></span><br></pre></td></tr></table></figure>

<p>打完收工</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>myblog</title>
    <url>/2020/03/02/myblog/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
